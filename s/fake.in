#!/bin/sh
# vim: sw=2 sts=2 et fdm=marker cms=\ #\ %s

set -e
set -u

basex="${basex:-@basex@}"

# need to protect this code from already-created fakes {{{
# this must be syntax-, not command-based,
# to prevent stumbling on a pre-existing fake.
[ "${FAKE_BINDIR-unset}" = unset ] || {
  opath="$PATH"
  npath=

  while [ -n "$opath" ]; do
    seg="${opath%%:*}"
    case "$opath" in
    *:*) opath="${opath#*:}" ;;
    *)   opath= ;;
    esac
    [ "$seg" = "$FAKE_BINDIR" ] || {
      npath="$npath:$seg"
    }
  done
  export PATH="${npath#:}"
}
# }}}

basex() # {{{
{
  command "$basex" "$@"
} # }}}

usage() # {{{
{
  local ex=${1-100}
  test $ex -ne 100 || printf >&2 'fake: error: missing operand\n'
  printf >&2 'fake: usage: %s -h|-hh\n' "${0##*/}"
  printf >&2 'fake: usage: %s [options] CMD [ARG...]\n' "${0##*/}"
  if test $ex -gt -2; then
    printf >&2 'fake: use `fake -hh` to display help\n'
  else
    cat >&2 <<-\EOF

	Options:

	  -h      Display short usage help.
	          Given twice, display full help.

	  -b      Body.  Created fake will consist of current stdin.
	  -c      Catchall.  Created fake will receive
	          any uses of CMD not covered by other,
	          more specific fakes.
	  -e      Error.  Created fake will emit current
	          stdin to its stderr.
	  -o      Output.  Created fake will emit current
	          stdin to its stdout.
	  -v      Verbose.  Reflect received argv on stderr.
	  -x N    Exit code.  Fake should exit with N.
EOF
  fi
  if test $ex -lt 0; then
    exit 0
  fi
  exit $ex
} # }}}

catchall=0
copy_body=nope
has_output=0
reflect=0
exitcode=
usage=0

while getopts hbceovx: OPTNAME; do
case "$OPTNAME" in
h) usage=$((usage - 1)) ;;

b) copy_body=asis ;;
c) catchall=1 ;;
e) copy_body=stderr ;;
o) copy_body=stdout ;;
v) reflect=1 ;;
x) exitcode="$OPTARG" ;;
esac
done; shift $((OPTIND - 1))

test $usage -eq 0 || usage $usage

if test $# -eq 0; then
  usage 100
fi

cmd="$1"; shift
bindir=${FAKE_BINDIR:?}
frontend="$bindir/$cmd"
impldir="$bindir/.$cmd"

mkdir -p "$impldir"

if test $catchall -eq 0; then
  name="$impldir/$#"
  for arg in "$@"; do
    name="$name-$(printf -- "%s" "$arg" | basex -e base32hex)"
  done
else
  name="$impldir/X"
fi

impl_has_body() # {{{
{
  cat > "${1:?}"
} # }}}
impl_has_errout() # {{{
{
  {
    printf -- "%s\n" "#!/bin/sh"
    printf -- "%s\n" "cat >&${1:?} <<\\EOF"
    cat
    printf -- "%s\n" "EOF"
  } > "$name"
} # }}}
impl_reflect() # {{{
{
  sed 's/^ *//' > "${1:?}" <<\EOF
  #!/bin/sh
  exec >&2
  printf "%s" "${ARGV0##*/}"
  test $# -eq 0 || printf " %s" "$*"
  printf "\n"
EOF
} # }}}
impl_default() # {{{
{
  {
    printf -- "%s\n" "#!/bin/sh"
  } > "${1:?}"
} # }}}

if test $copy_body = asis; then
  impl_has_body "$name"
elif test $copy_body = stderr; then
  impl_has_errout 2 "$name"
elif test $copy_body = stdout; then
  impl_has_errout 1 "$name"
elif test $reflect -ne 0; then
  impl_reflect "$name"
else
  impl_default "$name"
fi
test -z "$exitcode" || printf -- >> "$name" "exit %s\n" "$exitcode"
chmod +x "$name"

sed '1,/^#### BEGIN FRONTEND$/d' < "$0" |
sed \
  -e "s#PATH#$PATH" \
  -e "s#basex#$basex" \
  -e "s#impldir#$impldir" \
> "$frontend"
chmod a+x "$frontend"
exit

#### BEGIN FRONTEND
#!/bin/sh

export PATH="#PATH#"

impldir="#impldir#"
basex="${basex:-#basex#}"

basex() # {{{
{
  command "$basex" "$@"
} # }}}

expected() # {{{
{
  local name="${1##*/}"
  set --
  if test "$name" = 0; then
    :
  else
    local argc="${name%%-*}"
    local name="${name#*-}"
    local arg=
    local i=1
    while test $i -le $argc; do
      arg="${name%%-*}"
      name="${name#*-}"
      set -- "$@" "$(printf -- "%s" "$arg" | basex -d base32hex)"
      i=$((i+1))
    done
  fi
  printf -- "fake: expected: %s\n" "$ARGV0${*:+ $*}"
} # }}}

name=$#
for arg in "$@"; do
  name="$name-$(printf -- "%s" "$arg" | basex -e base32hex)"
done

export ARGV0="${0##*/}"

if test -x "$impldir/$name"; then
  exec "$impldir/$name" "$@"
elif test -x "$impldir/X"; then
  exec "$impldir/X" "$@"
fi

exec >&2

printf -- "fake: error: argv mismatch\n"
find "$impldir" -mindepth 1 -print | sort | while read name; do
  expected "$name"
done
printf -- "fake: received: %s" "$ARGV0"
test $# -eq 0 || printf -- " %s" "$@"
printf -- "\n"
exit 100
